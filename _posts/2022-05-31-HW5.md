---
layout: post
title: "Creating Webapps with Flask and Heroku"
author: Kelly Song
---

## Introduction

Hello everyone! Today we will be learning how to create a simple submission page with Flask.

The repository for this activity can be accessed here: https://github.com/k-song14/16BHW5

First, make sure you have your heroku app set up and download the necessary packages.

```python
from flask import Flask, g, render_template, request
import numpy as np
import sqlite3

app = Flask(__name__)
```

For our page, we will have three html files and 5 different functions. Each html page corresponds to a different webpage within our webapp; base.html is our initial page with the links to our submission page (submit.html) and view messages page (view.html). We will first focus on what's in our app.py before we check out our html files.


## Base page / base.html

We begin by rendering base.html for the initial page. Here is what it looks like:


{% block content %}
<link rel="stylesheet" href="{{ url_for('static', filename='mystyle.css') }}">

    <h2>A Simple Message Bank</h2>
        <nav> 
            <ul>
                <li><a href="/submit/">Submit a message</a></li>
                <li><a href="/view/">View messages</a></li>
            </ul>
        </nav>

{% endblock %}


We have a link to the page where you'll be able to submit a message, and a link to the page where you can see the messages. When you initially enter the webpage, this is the page you see.

![base.png](/images/base.png)

## __init__.py

```python
@app.route("/") 
def base():
    return render_template("base.html")
    
 ```

The code above (which is in the __init__.py file, is basically telling Flask to show the base html file when we just have "/" following our webapp's link.

We will now go over all of our functions in our __init__.py file, beginning with get_message_db(). 

### get_message_db()

This function (see code below) allows us to create a database for the inputted messages and names from the user (if there is not one already established; in that case, we just return that database). In order to do so, we must open a connection to the database and execute a SQL command.

```python
def get_message_db():
    try:
        return g.message_db
    except:
        #create our table
        g.message_db = sqlite3.connect("messages_db.sqlite")
        cmd = \
        '''
        CREATE TABLE IF NOT EXISTS `messages` (
            id  INTEGER PRIMARY KEY AUTOINCREMENT  ,
            name TEXT NOT NULL,
            message TEXT NOT NULL
        );
        '''
        cursor = g.message_db.cursor()
        cursor.execute(cmd)

        return g.message_db

```

### insert_message()

Next, after we've created our database, we need a function that will allow us to insert the messages and names of the users into the database. That's where insert_messages() comes in. This function sends requests for the messages and names, opens a connection to our database, and inserts the message and name into the database.

```python

def insert_message():
    #get message and name inputted by user
    message = request.form['message']
    name = request.form['name']

    #open connection to database
    conn = get_message_db()

    #insert into our database
    cmd = \
    '''
    INSERT INTO messages (name, message) VALUES ('{name}', '{message}');
    '''
    cursor = conn.cursor()
    cursor.execute(cmd)
    conn.commit()
    conn.close()

    return name, message
    
```

## Submit page / submit.html

Now that we've established our database and accounted for user input, let's check out the function for our submit page. This function (submit()) will show the submit html file if the user just visits the url. However, if the user decides to submit their name and/or message, it will return a message containing what was inputted. It will also call on our function insert_message so that the user input is inserted into our database. 

```python

@app.route("/submit/", methods=['POST', 'GET'])
def submit():
    if request.method == 'GET':
        # if the user just visits the url
        return render_template('submit.html')
    else:
        try:
            # if the user submits the form, call on insert_message, which will put input into database
            name, message = insert_message()
            # if user submits
            return render_template('submit.html', submit=True, message=message, name=name)
        except:
            return render_template('submit.html', error=True)

```
Our submit.html file contains the following code:

{% block content %}
<link rel="stylesheet" href="{{ url_for('static', filename='mystyle.css') }}">
 
<h2>A Simple Message Bank</h2>
<nav> 
    <ul>
        <li><a href="/submit/">Submit a message</a></li>
        <li><a href="/view/">View messages</a></li>
    </ul>
</nav>

<h2>Submit</h2>

<form method="post">
    <label for="message">Your message:</label>
    <br>
    <input name="message" id="message">
    <br>
    <label for="name">Your name or handle:</label>
    <br>
    <input name="name" id="name">
    <br>
    <input type="submit" value="Submit form">
    <input type="reset" value="Reset">
</form>



    {% if submit %}
        <br>
        <b>Hello {{name}}! </b>
        <br>
        <i>Your submitted message was:</i> 
        <br>
        <br>
        "{{message}}"
        <br>
        - {{name}}
        <br>
        <br>
        Click <a href="/view/">here</a> to see existing messages!
        <br>
        Click <a href="/submit/">here</a> to submit another form!
    {% endif %}

{% endblock %}

This code links the html file to our style sheet (which will be discussed in more detail later). As we can see, this page contains a form that allows the user to submit their message and name, a submit button, and a reset button. Once they submit their message/name, a message pops up with a couple links the user can access (see example below).

![submit1.png](/images/submit1.png)
![submit2.png](/images/submit2.png)

## View page / view.html

Now, we'll work on the functions responsible for our "view messages" page. The function random_messages(n) will give us n random messages that were inputted by the user(s), followed by their names. To do so, we have to call on our database and execute a SQL command that will take messages from the message database and randomly order them. Since we only want n messages, we limit it to n messages.

```python

def random_messages(n):
    # refer to insert_messages and discussion view function 
    # HINT SQL command - ORDER BY RANDOM()

    #connect database
    conn = get_message_db()

    #SQL command
    cmd = \
    '''
    SELECT * FROM messages ORDER BY RANDOM() LIMIT {n}

    '''

    cursor = conn.cursor()
    #take out SQL command and execute it
    cursor.execute(cmd)
    all_msg = cursor.fetchall()
    conn.close()

    return  all_msg

```

For our "view messages" page, we display our view html file 

```python

@app.route('/view/')
def view():

    #call on random_messages() function
    return render_template('view.html', messages= random_messages(5))

```
Our view.html page is defined by the following code:

{% block content %}
<link rel="stylesheet" href="{{ url_for('static', filename='mystyle.css') }}">

<h2>A Simple Message Bank</h2>
<nav> 
    <ul>
        <li><a href="/submit/">Submit a message</a></li>
        <li><a href="/view/">View messages</a></li>
    </ul>
</nav>

    <body>
        <div>

            <h2>Your messages:</h2>
            <br>
            {% for message in messages %}
                <br>
                "{{message[1]}}"
                <br>
                -{{message[2]}}
                <br>
            {% endfor %}
        </div>

    </body>

{% endblock %}

As we can see, the page contains a message "Your messages:", followed by the user's message and name (see example below).

![view.png](/images/view.png)

## CSS styling

Once you've created the web app, you can style it using CSS! For my web app, I went simple by doing a lavender background and purple titles. I styled the form so that it's the same shade, and for the buttons and input boxes in the form, I made it so that when the user hovers over them, a purple outline can be seen. Check out the code below!

html {
    font-family: sans-serif;
    background-color: lavender;
    padding: 1rem;
}

h1 {
    color: black;
    font-family: sans-serif;
    font-weight: bold;
    margin: 1rem 0;
    text-align: center;
}

h2 {

    font-weight: bold;
    color: purple;
}

form {
    background: lavender;
    width: 50%;
}

input:hover{

    border: 2px solid indigo;
    border-radius: 4px;
  }
  
As always, thank you for reading!!
    
